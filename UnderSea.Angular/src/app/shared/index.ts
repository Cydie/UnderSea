/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.5.0.0 (NJsonSchema v10.1.15.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAttacksClient {
    /**
     * @return Success
     */
    getoutgoing(): Observable<OutgoingAttackViewModel[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    send(body: AttackDTO | undefined): Observable<SimpleUnitViewModel[]>;
    /**
     * @param searchPhrase (optional) 
     * @param page (optional) 
     * @param itemPerPage (optional) 
     * @return Success
     */
    searchtargets(searchPhrase: string | null | undefined, page: number | null | undefined, itemPerPage: number | null | undefined): Observable<ScoreboardViewModel[]>;
    /**
     * @return Success
     */
    getunits(): Observable<AvailableUnitViewModel[]>;
}

@Injectable({
    providedIn: 'root'
})
export class AttacksClient implements IAttacksClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getoutgoing(): Observable<OutgoingAttackViewModel[]> {
        let url_ = this.baseUrl + "/api/Attacks/getoutgoing";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetoutgoing(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetoutgoing(<any>response_);
                } catch (e) {
                    return <Observable<OutgoingAttackViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OutgoingAttackViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetoutgoing(response: HttpResponseBase): Observable<OutgoingAttackViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OutgoingAttackViewModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OutgoingAttackViewModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    send(body: AttackDTO | undefined): Observable<SimpleUnitViewModel[]> {
        let url_ = this.baseUrl + "/api/Attacks/send";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSend(<any>response_);
                } catch (e) {
                    return <Observable<SimpleUnitViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimpleUnitViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processSend(response: HttpResponseBase): Observable<SimpleUnitViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SimpleUnitViewModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleUnitViewModel[]>(<any>null);
    }

    /**
     * @param searchPhrase (optional) 
     * @param page (optional) 
     * @param itemPerPage (optional) 
     * @return Success
     */
    searchtargets(searchPhrase: string | null | undefined, page: number | null | undefined, itemPerPage: number | null | undefined): Observable<ScoreboardViewModel[]> {
        let url_ = this.baseUrl + "/api/Attacks/searchtargets?";
        if (searchPhrase !== undefined && searchPhrase !== null)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (itemPerPage !== undefined && itemPerPage !== null)
            url_ += "ItemPerPage=" + encodeURIComponent("" + itemPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchtargets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchtargets(<any>response_);
                } catch (e) {
                    return <Observable<ScoreboardViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScoreboardViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processSearchtargets(response: HttpResponseBase): Observable<ScoreboardViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ScoreboardViewModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScoreboardViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    getunits(): Observable<AvailableUnitViewModel[]> {
        let url_ = this.baseUrl + "/api/Attacks/getunits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetunits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetunits(<any>response_);
                } catch (e) {
                    return <Observable<AvailableUnitViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AvailableUnitViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetunits(response: HttpResponseBase): Observable<AvailableUnitViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AvailableUnitViewModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AvailableUnitViewModel[]>(<any>null);
    }
}

export interface IAuthClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterDTO | undefined): Observable<TokensViewModel>;
    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginDTO | undefined): Observable<TokensViewModel>;
    /**
     * @return Success
     */
    logout(): Observable<void>;
    /**
     * @return Success
     */
    renew(): Observable<TokensViewModel>;
}

@Injectable({
    providedIn: 'root'
})
export class AuthClient implements IAuthClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterDTO | undefined): Observable<TokensViewModel> {
        let url_ = this.baseUrl + "/api/Auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<TokensViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TokensViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<TokensViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokensViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokensViewModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginDTO | undefined): Observable<TokensViewModel> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<TokensViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TokensViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<TokensViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokensViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokensViewModel>(<any>null);
    }

    /**
     * @return Success
     */
    logout(): Observable<void> {
        let url_ = this.baseUrl + "/api/Auth/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    renew(): Observable<TokensViewModel> {
        let url_ = this.baseUrl + "/api/Auth/renew";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenew(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenew(<any>response_);
                } catch (e) {
                    return <Observable<TokensViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<TokensViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processRenew(response: HttpResponseBase): Observable<TokensViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokensViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TokensViewModel>(<any>null);
    }
}

export interface IApiClient {
    /**
     * @return Success
     */
    buildings(): Observable<BuildingInfoViewModel[]>;
    /**
     * @return Success
     */
    mainPage(): Observable<MainPageViewModel>;
    /**
     * @param searchPhrase (optional) 
     * @param page (optional) 
     * @param itemPerPage (optional) 
     * @return Success
     */
    scoreboard(searchPhrase: string | null | undefined, page: number | null | undefined, itemPerPage: number | null | undefined): Observable<ScoreboardViewModel[]>;
    /**
     * @return Success
     */
    unitsGet(): Observable<UnitViewModel[]>;
    /**
     * @param body (optional) 
     * @return Success
     */
    unitsPost(body: UnitPurchaseDTO[] | null | undefined): Observable<SimpleUnitViewModel[]>;
    /**
     * @return Success
     */
    upgrades(): Observable<UpgradeViewModel[]>;
}

@Injectable({
    providedIn: 'root'
})
export class ApiClient implements IApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    buildings(): Observable<BuildingInfoViewModel[]> {
        let url_ = this.baseUrl + "/api/Buildings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuildings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuildings(<any>response_);
                } catch (e) {
                    return <Observable<BuildingInfoViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BuildingInfoViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processBuildings(response: HttpResponseBase): Observable<BuildingInfoViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BuildingInfoViewModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuildingInfoViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    mainPage(): Observable<MainPageViewModel> {
        let url_ = this.baseUrl + "/api/MainPage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMainPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMainPage(<any>response_);
                } catch (e) {
                    return <Observable<MainPageViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<MainPageViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processMainPage(response: HttpResponseBase): Observable<MainPageViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MainPageViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MainPageViewModel>(<any>null);
    }

    /**
     * @param searchPhrase (optional) 
     * @param page (optional) 
     * @param itemPerPage (optional) 
     * @return Success
     */
    scoreboard(searchPhrase: string | null | undefined, page: number | null | undefined, itemPerPage: number | null | undefined): Observable<ScoreboardViewModel[]> {
        let url_ = this.baseUrl + "/api/Scoreboard?";
        if (searchPhrase !== undefined && searchPhrase !== null)
            url_ += "SearchPhrase=" + encodeURIComponent("" + searchPhrase) + "&";
        if (page !== undefined && page !== null)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (itemPerPage !== undefined && itemPerPage !== null)
            url_ += "ItemPerPage=" + encodeURIComponent("" + itemPerPage) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScoreboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScoreboard(<any>response_);
                } catch (e) {
                    return <Observable<ScoreboardViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScoreboardViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processScoreboard(response: HttpResponseBase): Observable<ScoreboardViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ScoreboardViewModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScoreboardViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    unitsGet(): Observable<UnitViewModel[]> {
        let url_ = this.baseUrl + "/api/Units";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnitsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnitsGet(<any>response_);
                } catch (e) {
                    return <Observable<UnitViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processUnitsGet(response: HttpResponseBase): Observable<UnitViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UnitViewModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitViewModel[]>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unitsPost(body: UnitPurchaseDTO[] | null | undefined): Observable<SimpleUnitViewModel[]> {
        let url_ = this.baseUrl + "/api/Units";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnitsPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnitsPost(<any>response_);
                } catch (e) {
                    return <Observable<SimpleUnitViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SimpleUnitViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processUnitsPost(response: HttpResponseBase): Observable<SimpleUnitViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SimpleUnitViewModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SimpleUnitViewModel[]>(<any>null);
    }

    /**
     * @return Success
     */
    upgrades(): Observable<UpgradeViewModel[]> {
        let url_ = this.baseUrl + "/api/Upgrades";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgrades(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgrades(<any>response_);
                } catch (e) {
                    return <Observable<UpgradeViewModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpgradeViewModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpgrades(response: HttpResponseBase): Observable<UpgradeViewModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UpgradeViewModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpgradeViewModel[]>(<any>null);
    }
}

export interface IBuildingsClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    purchase(body: number | undefined): Observable<BuildingInfoViewModel>;
}

@Injectable({
    providedIn: 'root'
})
export class BuildingsClient implements IBuildingsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    purchase(body: number | undefined): Observable<BuildingInfoViewModel> {
        let url_ = this.baseUrl + "/api/Buildings/purchase";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPurchase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPurchase(<any>response_);
                } catch (e) {
                    return <Observable<BuildingInfoViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<BuildingInfoViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processPurchase(response: HttpResponseBase): Observable<BuildingInfoViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BuildingInfoViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BuildingInfoViewModel>(<any>null);
    }
}

export interface IMainPageClient {
    /**
     * @param rounds (optional) 
     * @return Success
     */
    newround(rounds: number | undefined): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class MainPageClient implements IMainPageClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param rounds (optional) 
     * @return Success
     */
    newround(rounds: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/MainPage/newround?";
        if (rounds === null)
            throw new Error("The parameter 'rounds' cannot be null.");
        else if (rounds !== undefined)
            url_ += "rounds=" + encodeURIComponent("" + rounds) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewround(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewround(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processNewround(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

export interface IUpgradesClient {
    /**
     * @param body (optional) 
     * @return Success
     */
    research(body: number | undefined): Observable<UpgradeViewModel>;
}

@Injectable({
    providedIn: 'root'
})
export class UpgradesClient implements IUpgradesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    research(body: number | undefined): Observable<UpgradeViewModel> {
        let url_ = this.baseUrl + "/api/Upgrades/research";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResearch(<any>response_);
                } catch (e) {
                    return <Observable<UpgradeViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpgradeViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processResearch(response: HttpResponseBase): Observable<UpgradeViewModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpgradeViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpgradeViewModel>(<any>null);
    }
}

export class SimpleUnitViewModel implements ISimpleUnitViewModel {
    typeId?: number;
    count?: number;

    constructor(data?: ISimpleUnitViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeId = _data["typeId"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): SimpleUnitViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new SimpleUnitViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["count"] = this.count;
        return data; 
    }
}

export interface ISimpleUnitViewModel {
    typeId?: number;
    count?: number;
}

export class OutgoingAttackViewModel implements IOutgoingAttackViewModel {
    countryName?: string | undefined;
    units?: SimpleUnitViewModel[] | undefined;

    constructor(data?: IOutgoingAttackViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryName = _data["countryName"];
            if (Array.isArray(_data["units"])) {
                this.units = [] as any;
                for (let item of _data["units"])
                    this.units!.push(SimpleUnitViewModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OutgoingAttackViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new OutgoingAttackViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        if (Array.isArray(this.units)) {
            data["units"] = [];
            for (let item of this.units)
                data["units"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOutgoingAttackViewModel {
    countryName?: string | undefined;
    units?: SimpleUnitViewModel[] | undefined;
}

export class SendUnitDTO implements ISendUnitDTO {
    id?: number;
    sendCount?: number;

    constructor(data?: ISendUnitDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sendCount = _data["sendCount"];
        }
    }

    static fromJS(data: any): SendUnitDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SendUnitDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sendCount"] = this.sendCount;
        return data; 
    }
}

export interface ISendUnitDTO {
    id?: number;
    sendCount?: number;
}

export class AttackDTO implements IAttackDTO {
    defenderUserId?: number;
    attackingUnits?: SendUnitDTO[] | undefined;

    constructor(data?: IAttackDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defenderUserId = _data["defenderUserId"];
            if (Array.isArray(_data["attackingUnits"])) {
                this.attackingUnits = [] as any;
                for (let item of _data["attackingUnits"])
                    this.attackingUnits!.push(SendUnitDTO.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AttackDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AttackDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defenderUserId"] = this.defenderUserId;
        if (Array.isArray(this.attackingUnits)) {
            data["attackingUnits"] = [];
            for (let item of this.attackingUnits)
                data["attackingUnits"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAttackDTO {
    defenderUserId?: number;
    attackingUnits?: SendUnitDTO[] | undefined;
}

export class ScoreboardViewModel implements IScoreboardViewModel {
    id?: number;
    place?: number;
    userName?: string | undefined;
    score?: number;

    constructor(data?: IScoreboardViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.place = _data["place"];
            this.userName = _data["userName"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): ScoreboardViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ScoreboardViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["place"] = this.place;
        data["userName"] = this.userName;
        data["score"] = this.score;
        return data; 
    }
}

export interface IScoreboardViewModel {
    id?: number;
    place?: number;
    userName?: string | undefined;
    score?: number;
}

export class AvailableUnitViewModel implements IAvailableUnitViewModel {
    id?: number;
    name?: string | undefined;
    availableCount?: number;
    imageUrl?: string | undefined;

    constructor(data?: IAvailableUnitViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.availableCount = _data["availableCount"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): AvailableUnitViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableUnitViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["availableCount"] = this.availableCount;
        data["imageUrl"] = this.imageUrl;
        return data; 
    }
}

export interface IAvailableUnitViewModel {
    id?: number;
    name?: string | undefined;
    availableCount?: number;
    imageUrl?: string | undefined;
}

export class RegisterDTO implements IRegisterDTO {
    userName?: string | undefined;
    password?: string | undefined;
    countryName?: string | undefined;

    constructor(data?: IRegisterDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.countryName = _data["countryName"];
        }
    }

    static fromJS(data: any): RegisterDTO {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["countryName"] = this.countryName;
        return data; 
    }
}

export interface IRegisterDTO {
    userName?: string | undefined;
    password?: string | undefined;
    countryName?: string | undefined;
}

export class TokensViewModel implements ITokensViewModel {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;

    constructor(data?: ITokensViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): TokensViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new TokensViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        return data; 
    }
}

export interface ITokensViewModel {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
}

export class LoginDTO implements ILoginDTO {
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginDTO {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILoginDTO {
    userName?: string | undefined;
    password?: string | undefined;
}

export class BuildingInfoViewModel implements IBuildingInfoViewModel {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    count?: number;
    price?: number;
    imageUrl?: string | undefined;
    remainingRounds?: number;

    constructor(data?: IBuildingInfoViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.count = _data["count"];
            this.price = _data["price"];
            this.imageUrl = _data["imageUrl"];
            this.remainingRounds = _data["remainingRounds"];
        }
    }

    static fromJS(data: any): BuildingInfoViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingInfoViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["count"] = this.count;
        data["price"] = this.price;
        data["imageUrl"] = this.imageUrl;
        data["remainingRounds"] = this.remainingRounds;
        return data; 
    }
}

export interface IBuildingInfoViewModel {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    count?: number;
    price?: number;
    imageUrl?: string | undefined;
    remainingRounds?: number;
}

export class UnitType implements IUnitType {
    id?: number;
    name?: string | undefined;
    price?: number;
    attackScore?: number;
    defenseScore?: number;
    pearlCostPerTurn?: number;
    coralCostPerTurn?: number;
    imageUrl?: string | undefined;
    score?: number;

    constructor(data?: IUnitType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.price = _data["price"];
            this.attackScore = _data["attackScore"];
            this.defenseScore = _data["defenseScore"];
            this.pearlCostPerTurn = _data["pearlCostPerTurn"];
            this.coralCostPerTurn = _data["coralCostPerTurn"];
            this.imageUrl = _data["imageUrl"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): UnitType {
        data = typeof data === 'object' ? data : {};
        let result = new UnitType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["price"] = this.price;
        data["attackScore"] = this.attackScore;
        data["defenseScore"] = this.defenseScore;
        data["pearlCostPerTurn"] = this.pearlCostPerTurn;
        data["coralCostPerTurn"] = this.coralCostPerTurn;
        data["imageUrl"] = this.imageUrl;
        data["score"] = this.score;
        return data; 
    }
}

export interface IUnitType {
    id?: number;
    name?: string | undefined;
    price?: number;
    attackScore?: number;
    defenseScore?: number;
    pearlCostPerTurn?: number;
    coralCostPerTurn?: number;
    imageUrl?: string | undefined;
    score?: number;
}

export class Unit implements IUnit {
    id?: number;
    attackId?: number | undefined;
    unitGroupId?: number;
    count?: number;
    typeId?: number;
    type?: UnitType;

    constructor(data?: IUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.attackId = _data["attackId"];
            this.unitGroupId = _data["unitGroupId"];
            this.count = _data["count"];
            this.typeId = _data["typeId"];
            this.type = _data["type"] ? UnitType.fromJS(_data["type"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Unit {
        data = typeof data === 'object' ? data : {};
        let result = new Unit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["attackId"] = this.attackId;
        data["unitGroupId"] = this.unitGroupId;
        data["count"] = this.count;
        data["typeId"] = this.typeId;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUnit {
    id?: number;
    attackId?: number | undefined;
    unitGroupId?: number;
    count?: number;
    typeId?: number;
    type?: UnitType;
}

export class BuildingType implements IBuildingType {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    price?: number;
    populationBonus?: number;
    coralBonus?: number;
    unitStorage?: number;
    imageUrl?: string | undefined;
    score?: number;

    constructor(data?: IBuildingType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.price = _data["price"];
            this.populationBonus = _data["populationBonus"];
            this.coralBonus = _data["coralBonus"];
            this.unitStorage = _data["unitStorage"];
            this.imageUrl = _data["imageUrl"];
            this.score = _data["score"];
        }
    }

    static fromJS(data: any): BuildingType {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["price"] = this.price;
        data["populationBonus"] = this.populationBonus;
        data["coralBonus"] = this.coralBonus;
        data["unitStorage"] = this.unitStorage;
        data["imageUrl"] = this.imageUrl;
        data["score"] = this.score;
        return data; 
    }
}

export interface IBuildingType {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    price?: number;
    populationBonus?: number;
    coralBonus?: number;
    unitStorage?: number;
    imageUrl?: string | undefined;
    score?: number;
}

export class Building implements IBuilding {
    id?: number;
    buildingGroupId?: number;
    typeId?: number;
    type?: BuildingType;
    count?: number;
    underConstructionCount?: number;
    constructionTimeLeft?: number;
    readonly coralBonusTotal?: number;

    constructor(data?: IBuilding) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.buildingGroupId = _data["buildingGroupId"];
            this.typeId = _data["typeId"];
            this.type = _data["type"] ? BuildingType.fromJS(_data["type"]) : <any>undefined;
            this.count = _data["count"];
            this.underConstructionCount = _data["underConstructionCount"];
            this.constructionTimeLeft = _data["constructionTimeLeft"];
            (<any>this).coralBonusTotal = _data["coralBonusTotal"];
        }
    }

    static fromJS(data: any): Building {
        data = typeof data === 'object' ? data : {};
        let result = new Building();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["buildingGroupId"] = this.buildingGroupId;
        data["typeId"] = this.typeId;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["count"] = this.count;
        data["underConstructionCount"] = this.underConstructionCount;
        data["constructionTimeLeft"] = this.constructionTimeLeft;
        data["coralBonusTotal"] = this.coralBonusTotal;
        return data; 
    }
}

export interface IBuilding {
    id?: number;
    buildingGroupId?: number;
    typeId?: number;
    type?: BuildingType;
    count?: number;
    underConstructionCount?: number;
    constructionTimeLeft?: number;
    coralBonusTotal?: number;
}

export class BuildingGroup implements IBuildingGroup {
    id?: number;
    buildings?: Building[] | undefined;

    constructor(data?: IBuildingGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["buildings"])) {
                this.buildings = [] as any;
                for (let item of _data["buildings"])
                    this.buildings!.push(Building.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BuildingGroup {
        data = typeof data === 'object' ? data : {};
        let result = new BuildingGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.buildings)) {
            data["buildings"] = [];
            for (let item of this.buildings)
                data["buildings"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IBuildingGroup {
    id?: number;
    buildings?: Building[] | undefined;
}

export class StatusBarResource implements IStatusBarResource {
    pearlCount?: number;
    pearlProductionCount?: number;
    pearlPictureUrl?: string | undefined;
    coralCount?: number;
    coralProductionCount?: number;
    coralPictureUrl?: string | undefined;

    constructor(data?: IStatusBarResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pearlCount = _data["pearlCount"];
            this.pearlProductionCount = _data["pearlProductionCount"];
            this.pearlPictureUrl = _data["pearlPictureUrl"];
            this.coralCount = _data["coralCount"];
            this.coralProductionCount = _data["coralProductionCount"];
            this.coralPictureUrl = _data["coralPictureUrl"];
        }
    }

    static fromJS(data: any): StatusBarResource {
        data = typeof data === 'object' ? data : {};
        let result = new StatusBarResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pearlCount"] = this.pearlCount;
        data["pearlProductionCount"] = this.pearlProductionCount;
        data["pearlPictureUrl"] = this.pearlPictureUrl;
        data["coralCount"] = this.coralCount;
        data["coralProductionCount"] = this.coralProductionCount;
        data["coralPictureUrl"] = this.coralPictureUrl;
        return data; 
    }
}

export interface IStatusBarResource {
    pearlCount?: number;
    pearlProductionCount?: number;
    pearlPictureUrl?: string | undefined;
    coralCount?: number;
    coralProductionCount?: number;
    coralPictureUrl?: string | undefined;
}

export class StatusBarViewModel implements IStatusBarViewModel {
    units?: Unit[] | undefined;
    buildings?: BuildingGroup;
    roundCount?: number;
    scoreboardPosition?: number;
    resources?: StatusBarResource;

    constructor(data?: IStatusBarViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["units"])) {
                this.units = [] as any;
                for (let item of _data["units"])
                    this.units!.push(Unit.fromJS(item));
            }
            this.buildings = _data["buildings"] ? BuildingGroup.fromJS(_data["buildings"]) : <any>undefined;
            this.roundCount = _data["roundCount"];
            this.scoreboardPosition = _data["scoreboardPosition"];
            this.resources = _data["resources"] ? StatusBarResource.fromJS(_data["resources"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StatusBarViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new StatusBarViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.units)) {
            data["units"] = [];
            for (let item of this.units)
                data["units"].push(item.toJSON());
        }
        data["buildings"] = this.buildings ? this.buildings.toJSON() : <any>undefined;
        data["roundCount"] = this.roundCount;
        data["scoreboardPosition"] = this.scoreboardPosition;
        data["resources"] = this.resources ? this.resources.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStatusBarViewModel {
    units?: Unit[] | undefined;
    buildings?: BuildingGroup;
    roundCount?: number;
    scoreboardPosition?: number;
    resources?: StatusBarResource;
}

export class StructuresViewModel implements IStructuresViewModel {
    flowManager?: boolean;
    reefCastle?: boolean;
    mudTractor?: boolean;
    mudHarvester?: boolean;
    coralWall?: boolean;
    sonarCannon?: boolean;
    underwaterMartialArts?: boolean;
    alchemy?: boolean;

    constructor(data?: IStructuresViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.flowManager = _data["flowManager"];
            this.reefCastle = _data["reefCastle"];
            this.mudTractor = _data["mudTractor"];
            this.mudHarvester = _data["mudHarvester"];
            this.coralWall = _data["coralWall"];
            this.sonarCannon = _data["sonarCannon"];
            this.underwaterMartialArts = _data["underwaterMartialArts"];
            this.alchemy = _data["alchemy"];
        }
    }

    static fromJS(data: any): StructuresViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new StructuresViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["flowManager"] = this.flowManager;
        data["reefCastle"] = this.reefCastle;
        data["mudTractor"] = this.mudTractor;
        data["mudHarvester"] = this.mudHarvester;
        data["coralWall"] = this.coralWall;
        data["sonarCannon"] = this.sonarCannon;
        data["underwaterMartialArts"] = this.underwaterMartialArts;
        data["alchemy"] = this.alchemy;
        return data; 
    }
}

export interface IStructuresViewModel {
    flowManager?: boolean;
    reefCastle?: boolean;
    mudTractor?: boolean;
    mudHarvester?: boolean;
    coralWall?: boolean;
    sonarCannon?: boolean;
    underwaterMartialArts?: boolean;
    alchemy?: boolean;
}

export class MainPageViewModel implements IMainPageViewModel {
    statusBar?: StatusBarViewModel;
    countryName?: string | undefined;
    structures?: StructuresViewModel;

    constructor(data?: IMainPageViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.statusBar = _data["statusBar"] ? StatusBarViewModel.fromJS(_data["statusBar"]) : <any>undefined;
            this.countryName = _data["countryName"];
            this.structures = _data["structures"] ? StructuresViewModel.fromJS(_data["structures"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MainPageViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new MainPageViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusBar"] = this.statusBar ? this.statusBar.toJSON() : <any>undefined;
        data["countryName"] = this.countryName;
        data["structures"] = this.structures ? this.structures.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IMainPageViewModel {
    statusBar?: StatusBarViewModel;
    countryName?: string | undefined;
    structures?: StructuresViewModel;
}

export class UnitViewModel implements IUnitViewModel {
    id?: number;
    name?: string | undefined;
    count?: number;
    attackScore?: number;
    defenseScore?: number;
    pearlCostPerTurn?: number;
    coralCostPerTurn?: number;
    price?: number;
    imageUrl?: string | undefined;

    constructor(data?: IUnitViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.count = _data["count"];
            this.attackScore = _data["attackScore"];
            this.defenseScore = _data["defenseScore"];
            this.pearlCostPerTurn = _data["pearlCostPerTurn"];
            this.coralCostPerTurn = _data["coralCostPerTurn"];
            this.price = _data["price"];
            this.imageUrl = _data["imageUrl"];
        }
    }

    static fromJS(data: any): UnitViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UnitViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["count"] = this.count;
        data["attackScore"] = this.attackScore;
        data["defenseScore"] = this.defenseScore;
        data["pearlCostPerTurn"] = this.pearlCostPerTurn;
        data["coralCostPerTurn"] = this.coralCostPerTurn;
        data["price"] = this.price;
        data["imageUrl"] = this.imageUrl;
        return data; 
    }
}

export interface IUnitViewModel {
    id?: number;
    name?: string | undefined;
    count?: number;
    attackScore?: number;
    defenseScore?: number;
    pearlCostPerTurn?: number;
    coralCostPerTurn?: number;
    price?: number;
    imageUrl?: string | undefined;
}

export class UnitPurchaseDTO implements IUnitPurchaseDTO {
    typeId?: number;
    count?: number;

    constructor(data?: IUnitPurchaseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.typeId = _data["typeId"];
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): UnitPurchaseDTO {
        data = typeof data === 'object' ? data : {};
        let result = new UnitPurchaseDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeId"] = this.typeId;
        data["count"] = this.count;
        return data; 
    }
}

export interface IUnitPurchaseDTO {
    typeId?: number;
    count?: number;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data; 
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class UpgradeViewModel implements IUpgradeViewModel {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
    isPurchased?: boolean;
    remainingRounds?: number;

    constructor(data?: IUpgradeViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.imageUrl = _data["imageUrl"];
            this.isPurchased = _data["isPurchased"];
            this.remainingRounds = _data["remainingRounds"];
        }
    }

    static fromJS(data: any): UpgradeViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpgradeViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["imageUrl"] = this.imageUrl;
        data["isPurchased"] = this.isPurchased;
        data["remainingRounds"] = this.remainingRounds;
        return data; 
    }
}

export interface IUpgradeViewModel {
    id?: number;
    name?: string | undefined;
    description?: string | undefined;
    imageUrl?: string | undefined;
    isPurchased?: boolean;
    remainingRounds?: number;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}